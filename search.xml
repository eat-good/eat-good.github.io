<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title></title>
      <link href="/2023/03/08/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE%E4%B8%8E%E7%BB%A7%E6%89%BF/"/>
      <url>/2023/03/08/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE%E4%B8%8E%E7%BB%A7%E6%89%BF/</url>
      
        <content type="html"><![CDATA[<h1 id="原型与原型链与继承"><a href="#原型与原型链与继承" class="headerlink" title="原型与原型链与继承"></a><strong>原型与原型链与继承</strong></h1><h2 id="原型对象"><a href="#原型对象" class="headerlink" title="原型对象"></a>原型对象</h2><p> 在js中，每一个函数类型的数据，都有一个叫做prototype的属性，这个属性指向的是一个对象，就是所谓的原型对象。 </p><img src="C:\Users\GH\AppData\Roaming\Typora\typora-user-images\1668757590081.png" alt="1668757590081" style="zoom:50%;" /><p> 对于原型对象来说，它有个constructor属性，指向它的构造函数。 </p><p><img src="C:\Users\GH\AppData\Roaming\Typora\typora-user-images\1668757614186.png" alt="1668757614186"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">   <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">   <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">species</span> = <span class="string">&#x27;人类&#x27;</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">say</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> per1 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;xiaoming&#x27;</span>, <span class="number">20</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="原型对象有什么用呢？"><a href="#原型对象有什么用呢？" class="headerlink" title="原型对象有什么用呢？"></a>原型对象有什么用呢？</h3><p>最主要的作用就是用来存放实例对象的公有属性和公有方法。</p><p>上面那个例子里species属性和say方法对于所有实例来说都一样，放在构造函数里，那每创建一个实例，就会重复创建一次相同的属性和方法，显得有些浪费。这时候，如果把这些<strong>公有的属性和方法放在原型对象里共享</strong>，就会好很多。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">species</span> = <span class="string">&#x27;人类&#x27;</span>;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">say</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> per1 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;xiaoming&#x27;</span>, <span class="number">20</span>);</span><br><span class="line"><span class="keyword">let</span> per2 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;xiaohong&#x27;</span>, <span class="number">19</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(per1.<span class="property">species</span>); <span class="comment">// 人类 </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(per2.<span class="property">species</span>); <span class="comment">// 人类</span></span><br><span class="line"></span><br><span class="line">per1.<span class="title function_">say</span>(); <span class="comment">// Hello</span></span><br><span class="line">per2.<span class="title function_">say</span>(); <span class="comment">// Hello</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可是这里的species属性和say方法不是实例对象自己的，为什么可以直接用点运算符访问？这是因为在js中，对象如果在自己的这里找不到对应的属性或者方法，就会查看构造函数的原型对象，如果上面有这个属性或方法，就会返回属性值或调用方法。所以有时候，我们会用per1.constructor查看对象的构造函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(per1.constructor); // Person()</span><br></pre></td></tr></table></figure><p> 这个constructor是原型对象的属性，在这里能被实例对象使用，原因就是上面所说的。那如果原型对象上也没有找到想要的属性呢？这就要说到原型链了。 </p><h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><h3 id="两个概念"><a href="#两个概念" class="headerlink" title="两个概念"></a>两个概念</h3><ul><li>引用类型，都具有对象特性，即可自由扩展属性。(引用类型：Object、Array、Function、Date、RegExp)</li><li><strong>每个函数 <code>function</code> 都有一个显示原型 <code>prototype</code> ，每个实例对象都有一个隐式原型 <code>__proto__</code></strong></li></ul><h4 id="1-显示原型"><a href="#1-显示原型" class="headerlink" title="1. 显示原型"></a>1. 显示原型</h4><p>显示原型就是利用<strong>prototype</strong>属性查找原型，只是这个是函数类型数据的属性。</p><h4 id="2-隐式原型"><a href="#2-隐式原型" class="headerlink" title="2. 隐式原型"></a>2. 隐式原型</h4><p>隐式原型是利用__<strong>proto</strong>__属性查找原型，这个属性指向当前对象的构造函数的原型对象，<strong>这个属性是对象类型数据的属性，所以可以在实例对象上面使用：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(per1.__proto__ === Person.prototype); // true</span><br><span class="line">console.log(per2.__proto__ === Person.prototype); // true</span><br></pre></td></tr></table></figure><p> 根据上面，就可以得出constructor、prototype和__proto__之间的关系了： </p><p><img src="C:\Users\GH\AppData\Roaming\Typora\typora-user-images\1668758579532.png" alt="1668758579532"></p><h4 id="3-原型链"><a href="#3-原型链" class="headerlink" title="3. 原型链"></a>3. 原型链</h4><p>既然这个是对象类型的属性，而原型对象也是对象，那么原型对象就也有这个属性，但是原型对象的__proto__又是指向哪呢？</p><p>我们来分析一下，既然原型对象也是对象，那我们只要找到对象的构造函数就能知道__proto__的指向了。而js中，对象的构造函数就是Object()，所以对象的原型对象，就是Object.prototype。既然原型对象也是对象，那原型对象的原型对象，就也是Object.prototype。不过Object.prototype这个比较特殊，它没有上一层的原型对象，或者说是它的__proto__指向的是null。</p><p><img src="C:\Users\GH\AppData\Roaming\Typora\typora-user-images\1668759349364.png" alt="1668759349364"></p><p>到这里，就可以回答前面那个问题了，如果某个对象查找属性，自己和原型对象上都没有，那就会继续往原型对象的原型对象上去找，这个例子里就是Object.prototype，这里就是查找的终点站了，在这里找不到，就没有更上一层了（null里面啥也没有），直接返回undefined。</p><p>可以看出，整个查找过程都是顺着__proto__属性，一步一步往上查找，形成了像链条一样的结构，这个结构，就是原型链。所以，原型链也叫作隐式原型链。</p><p>正是因为这个原因，我们在创建对象、数组、函数等等数据的时候，都自带一些属性和方法，这些属性和方法是在它们的原型上面保存着，所以它们自创建起就可以直接使用那些属性和方法。</p><h2 id="函数也是一种对象"><a href="#函数也是一种对象" class="headerlink" title="函数也是一种对象"></a>函数也是一种对象</h2><p>函数在js中，也算是一种特殊的对象，所以，可以想到的是，函数是不是也有一个__proto__属性？答案是肯定的，既然如此，那就按上面的思路，先来找找函数对象的构造函数。</p><p>在js中，所有函数都可以看做是Function()的实例，而Person()和Object()都是函数，所以它们的构造函数就是Function()。Function()本身也是函数，所以Function()也是自己的实例，听起来既怪异又合理，但是就是这么回事。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">console.log(Person.constructor === Function); // true</span><br><span class="line">console.log(Object.constructor === Function); // true</span><br><span class="line">console.log(Function.constructor === Function); // true</span><br><span class="line"></span><br></pre></td></tr></table></figure><p> 既然知道了函数的构造函数，那么函数的__proto__指向我们也就知道了，就是Function.prototype。 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">console.log(Person.__proto__ === Function.prototype); // true</span><br><span class="line">console.log(Object.__proto__ === Function.prototype); // true</span><br><span class="line">console.log(Function.__proto__ === Function.prototype); // true</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="C:\Users\GH\AppData\Roaming\Typora\typora-user-images\1668759781375.png" alt="1668759781375"></p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ol><li>构造函数是使用了new关键字的函数，用来创建对象，所有函数都是Function()的实例</li><li>原型对象是用来存放实例对象的公有属性和公有方法的一个公共对象，所有原型对象都是Object()的实例</li><li>原型链又叫隐式原型链，是由__proto__属性串联起来，原型链的尽头是Object.prototype</li></ol><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><h3 id="借助原型实现继承"><a href="#借助原型实现继承" class="headerlink" title="借助原型实现继承"></a>借助原型实现继承</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var o = &#123;</span><br><span class="line">  a: 2,</span><br><span class="line">  m: function()&#123;</span><br><span class="line">    return this.a + 1;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">console.log(o.m()); // 3</span><br><span class="line">// 当调用 o.m 时，&#x27;this&#x27; 指向了 o.</span><br><span class="line"></span><br><span class="line">var p = Object.create(o);</span><br><span class="line">// p是一个继承自 o 的对象</span><br><span class="line"></span><br><span class="line">p.a = 4; // 创建 p 的自身属性 &#x27;a&#x27;</span><br><span class="line">console.log(p.m()); // 5</span><br><span class="line"></span><br></pre></td></tr></table></figure><p> 注：此处实现的是单继承 </p><h3 id="原型链-1"><a href="#原型链-1" class="headerlink" title="原型链"></a>原型链</h3><ul><li>get 对象属性时，会进行如下操作。<ul><li>首先在自身属性中查找，找到则返回</li><li>找不到则继续沿着 <code>__proto__</code> 这条链向上查找</li><li>如果最终没找到，返回 <code>undefined</code></li></ul></li><li>set 对象属性时，不会沿原型链向上查找赋值。如果当前对象中没有此属性，则直接添加此属性</li><li>方法一般定义在原型中，属性一般定义在构造函数上</li></ul><p><img src="C:\Users\GH\AppData\Roaming\Typora\typora-user-images\1668763434417.png" alt="1668763434417"></p><p> <strong>1. 所有函数的隐式原型都指向函数的显式原型</strong> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Foo.__proto__ === Function.prototype</span><br><span class="line">// true</span><br><span class="line">Object.__proto__ === Function.prototype</span><br><span class="line">// true</span><br><span class="line">Function.__proto__ === Function.prototype</span><br><span class="line">// true</span><br></pre></td></tr></table></figure><p> <strong>2. 实例的隐式原型指向其构造方法的显式原型</strong> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let foo = new Foo();</span><br><span class="line">foo.__proto__ === Foo.prototype;</span><br><span class="line">// true</span><br><span class="line">Foo.prototype.__proto__ === Object.prototype;</span><br><span class="line">// true</span><br><span class="line">Object.prototype.__proto__;</span><br><span class="line">// null</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2023/03/08/%E4%BA%8B%E4%BB%B6%E6%8D%95%E8%8E%B7%E3%80%81%E4%BA%8B%E4%BB%B6%E5%86%92%E6%B3%A1%E5%92%8C%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98/"/>
      <url>/2023/03/08/%E4%BA%8B%E4%BB%B6%E6%8D%95%E8%8E%B7%E3%80%81%E4%BA%8B%E4%BB%B6%E5%86%92%E6%B3%A1%E5%92%8C%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98/</url>
      
        <content type="html"><![CDATA[<h1 id="事件捕获、事件冒泡和事件委托"><a href="#事件捕获、事件冒泡和事件委托" class="headerlink" title="事件捕获、事件冒泡和事件委托"></a>事件捕获、事件冒泡和事件委托</h1><h3 id="1-事件和事件流"><a href="#1-事件和事件流" class="headerlink" title="1.事件和事件流"></a>1.事件和事件流</h3><p>事件：用户点击、滑动、键盘输入等</p><p>事件流：因为dom是一体的，事件触发的元素是相互嵌套的，会影响到其他元素，</p><img src="C:\Users\GH\AppData\Roaming\Typora\typora-user-images\1654587877333.png" alt="1654587877333" style="zoom:50%;" /><h3 id="2-事件捕获"><a href="#2-事件捕获" class="headerlink" title="2.事件捕获"></a>2.事件捕获</h3><p>从上到下，点击目标不会马上触发，而是从上面流动到底部触发</p><img src="C:\Users\GH\AppData\Roaming\Typora\typora-user-images\1654587958750.png" alt="1654587958750" style="zoom:25%;" /><h3 id="3-事件冒泡"><a href="#3-事件冒泡" class="headerlink" title="3.事件冒泡"></a>3.事件冒泡</h3><p>从下到上，点击目标会一层一层的向上触发。</p><img src="C:\Users\GH\AppData\Roaming\Typora\typora-user-images\1654587940201.png" alt="1654587940201" style="zoom:25%;" /><h3 id="4-事件流的三个过程"><a href="#4-事件流的三个过程" class="headerlink" title="4.事件流的三个过程"></a>4.事件流的三个过程</h3><p>规定了事件流的三个过程</p><img src="C:\Users\GH\AppData\Roaming\Typora\typora-user-images\1654588495571.png" alt="1654588495571" style="zoom:25%;" /><img src="C:\Users\GH\AppData\Roaming\Typora\typora-user-images\1654588513017.png" alt="1654588513017" style="zoom:25%;" /><h3 id="5事件默认绑定到事件冒泡阶段"><a href="#5事件默认绑定到事件冒泡阶段" class="headerlink" title="5事件默认绑定到事件冒泡阶段"></a>5事件默认绑定到事件冒泡阶段</h3><p>阻止事件冒泡和传播</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;div @click.capture= &quot;gotoDeatails&quot;&gt;// vue中更改事件的默认绑定顺序，改为捕获。</span><br><span class="line">    aaaaaaaaaaa</span><br><span class="line">    &lt;button @click.stop =&quot;like&quot;&gt;// vue中在绑定事件后加.stop</span><br><span class="line">        bbbbbbbbb</span><br><span class="line">    &lt;/button&gt;</span><br><span class="line">// js 阻止事件捕获冒泡</span><br><span class="line">function click() &#123;</span><br><span class="line">event.stopProopagation()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6面试题"><a href="#6面试题" class="headerlink" title="6面试题"></a>6面试题</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class = &quot;grandma&quot;&gt;grandma 奶奶</span><br><span class="line">    &lt;div class = &quot;mother&quot;&gt;mother 妈妈</span><br><span class="line">        &lt;div class = &quot;daughter&quot;&gt;daughter 女儿</span><br><span class="line">            &lt;div class = &quot;baby  bady 婴儿</span><br><span class="line">        &lt;/div&gt;            </span><br><span class="line">        &lt;/div&gt;            </span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">var grandma = document.getElementsByClassName(&quot;grandma&quot;[0]);</span><br><span class="line">var mother = document.getElementsByClassName(&quot;mother&quot;[0]);</span><br><span class="line">var daughter = document.getElementsByClassName(&quot;daughter&quot;[0]);</span><br><span class="line">var baby = document.getElementsByClassName(&quot;baby&quot;[0]);</span><br><span class="line">    function theName() &#123;console.log(&quot;我是&quot;+ this.className)&#125;</span><br><span class="line">    </span><br><span class="line">    baby,addEventListener(&#x27;click&#x27;,theName,false);//默认为false false即事件冒泡</span><br><span class="line">    mother,addEventListener(&#x27;click&#x27;,theName,true);// true 即事件捕获</span><br><span class="line">    daughter,addEventListener(&#x27;click&#x27;,theName,true);</span><br><span class="line">    grandma.onclick = theName; // 未进行任何设置，默认未冒泡。                </span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p><img src="C:\Users\GH\AppData\Roaming\Typora\typora-user-images\1654590086573.png" alt="1654590086573"></p><p>点击baby 输出什么：</p><p>mother  daughter baby grandma</p><p>捕获的优先级是比冒泡优先的，所以先执行了mother和daughter  因为是事件捕获，所以从上到下，先mother后daughter </p><p>捕获完成后， 执行冒泡，grandma 和baby ，事件冒泡。所以先执行baby后</p><h2 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h2><p>事件委托就是利用了事件冒泡的机制，将子的事件绑定到父或祖父上，这样可以</p><ol><li>可以大量节省内存占用，减少事件注册 </li><li>可以实现当新增子对象时无需再次对其绑定（动态绑定事件）</li></ol><h4 id="委托原理"><a href="#委托原理" class="headerlink" title="委托原理"></a><strong>委托原理</strong></h4><p> 给所有li添加点击事件，只要加到它们的父元素ul身上的根本原因是利用了事件冒泡。也即：无论点击哪个li，都会自动触发ul的点击事件，然后在ul里通过e.target能获得真正被点击的那个li，继而拿到它的innerHTML </p><h4 id="存在问题及解决方式"><a href="#存在问题及解决方式" class="headerlink" title="存在问题及解决方式"></a><strong>存在问题及解决方式</strong></h4><p> 如果ul里还有其他子元素例如span，可我只想给li加点击事件，用原来写的事件委托还行吗? </p><p>答案是否定的，因为根据事件冒泡原理，所有子元素点击后都会触发父元素的点击，因此，如果你点击了span，也会调用ul的点击事件，这就相当于给span也加了点击事件。这时候该怎么解决呢?</p><p>很简单，只要判断一下事件源是不是li就行了，如果是li才执行代码，否则不执行，代码如下：</p><p><img src="http://www.itcast.cn/files/image/202010/20201020103333870.jpg" alt="事件委托09"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if(e.target.nodeName.toLowerCase()==&#x27;li&#x27;) //toLowerCase()的用法把输入字符串中的大写字母全部转换为小写字符</span><br><span class="line">console.log()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="target定义："><a href="#target定义：" class="headerlink" title="target定义："></a>target定义：</h3><p>target 属性规定哪个 DOM 元素触发了该事件。<br>target 事件属性可返回事件的目标节点（触发该事件的节点），如生成事件的元素、文档或窗口。</p><p>语法：</p><p>event.target</p><p>event.target.nodeName 　　&#x2F;&#x2F;获取事件触发元素标签名（li，p，div，img，button…）</p><p>event.target.id　　　　　　&#x2F;&#x2F;获取事件触发元素id</p><p>event.target.className　　&#x2F;&#x2F;获取事件触发元素classname</p><p>event.target.innerHTML　 &#x2F;&#x2F;获取事件触发元素的内容（li）</p><p>nodeName属性 ： 节点的名字。<br>如果节点是元素节点，那么返回这个元素的名字。此时，相当于tagName属性。 </p><p> nodeType属性 ： 返回一个整数，代表这个节点的类型。<br>我们常用的3中类型：<br>nodeType &#x3D;&#x3D; 1 ： 元素节点<br>nodeType &#x3D;&#x3D; 2 ： 属性节点<br>nodeType &#x3D;&#x3D; 3 ： 文本节点 </p><h3 id="场景2：-新增元素没有绑定事件的问题"><a href="#场景2：-新增元素没有绑定事件的问题" class="headerlink" title="场景2： 新增元素没有绑定事件的问题"></a><strong>场景2： 新增元素没有绑定事件的问题</strong></h3><p> 界面描述：界面上有一个ul里面默认有5个li,并且还有一个按钮，当点击按钮就创建一个新的li，需要不管是默认有的li还是新的li都有点击事件。 </p><p><img src="http://www.itcast.cn/files/image/202010/20201020103923678.jpg" alt="事件委托13"></p><p> 解析：因为事件冒泡机制的存在，不管是原本有的li还是新创建的li，当事件触发时都会一级一级往上调用父元素的同名事件。因此，只要是点击的li标签，都会触发ul的点击事件，所以只要把事件加在ul身上就解决了不管新旧li标签都有点击事件的问题。 </p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2023/03/08/%E6%B7%B1%E5%BA%A6%E7%90%86%E8%A7%A3for%E5%BE%AA%E7%8E%AF%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F/"/>
      <url>/2023/03/08/%E6%B7%B1%E5%BA%A6%E7%90%86%E8%A7%A3for%E5%BE%AA%E7%8E%AF%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="深度理解for循环的作用域"><a href="#深度理解for循环的作用域" class="headerlink" title="深度理解for循环的作用域"></a>深度理解for循环的作用域</h1><h2 id="for循环中var（只有函数作用域和全局作用域）"><a href="#for循环中var（只有函数作用域和全局作用域）" class="headerlink" title="for循环中var（只有函数作用域和全局作用域）"></a>for循环中var（只有函数作用域和全局作用域）</h2><p>1、基础循环</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出为01234</span></span><br><span class="line"><span class="comment">//for循环每次循环执行一次，输出当前作用域下i的值</span></span><br></pre></td></tr></table></figure><p>2、添加异步</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i =<span class="number">0</span>;i &lt; <span class="number">5</span>;i++)&#123;</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(i)&#125;)</span><br><span class="line">&#125;<span class="comment">//输出为55555</span></span><br><span class="line"><span class="comment">/*for的每次循环都是同步执行，遇到了setTimeout宏任务定时器，进入异步队列回调函数不执行，</span></span><br><span class="line"><span class="comment">便先执行了5次的++</span></span><br><span class="line"><span class="comment">for循环是同步语句</span></span><br><span class="line"><span class="comment">当执行完毕，开始执行积压了5次的异步的setTimeout，这时作用域下的i是5</span></span><br><span class="line"><span class="comment">便输出了55555*/</span></span><br></pre></td></tr></table></figure><h2 id="for循环中let（块级作用域-中）"><a href="#for循环中let（块级作用域-中）" class="headerlink" title="for循环中let（块级作用域{}中）"></a>for循环中let（块级作用域{}中）</h2><p>1、基础循环</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (let i = 0;i &lt; 5; i++)&#123;</span><br><span class="line">console.log(i)</span><br><span class="line">&#125;// 01234</span><br></pre></td></tr></table></figure><p>2、添加异步</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">for (let i = 0;i &lt; 5;i++)&#123;</span><br><span class="line">setTimeout(()=&gt;console.log(i))</span><br><span class="line">console.log(i)</span><br><span class="line">&#125;</span><br><span class="line">//01234 01234</span><br><span class="line">//for循环的时候，会产生新的词法作用域（初始化也有），并在新的词法作用域中声明新的变量i并赋值</span><br><span class="line">//let的值一直在块级作用域中，输出的便是当前词法作用域下的变量i</span><br></pre></td></tr></table></figure><p>2、升级（查看setTimeout(()&#x3D;&gt; console.log(i));）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> timer = <span class="literal">null</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>;i &lt; <span class="number">5</span>;i++) &#123;</span><br><span class="line">timer = <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(i));</span><br><span class="line">    <span class="comment">//此处的timer收到的是异步回调的第几次数(全局内第几次的异步队列次数)存的不是i的值</span></span><br><span class="line">    <span class="comment">//for循环的词法作用域储存在这里。放异步开始执行，会从储存的词法作用域中提取i值</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;for循环内的:&#x27;</span>+timer)</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;for循环外的:&#x27;</span>+timer)</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br></pre></td></tr></table></figure><p>结论：for的每次循环都是同步执行，遇到了setTimeout宏任务定时器，进入异步队列回调函数不执行，</p><p>全局的异步队列是有默认排序的，timer &#x3D; setTimeout(()&#x3D;&gt; console.log(i));可以验证。</p><p>for循环的时候，会产生新的词法作用域（初始化也有），并在新的词法作用域中声明新的变量i并赋值</p><p>var：当使用var声明的时候存在了变量的提升，每次的i会被提升到词法作用域外，然后覆盖值，i&#x3D;最终的值</p><p>let：let声明的变量提升是存在块级作用域{}中的，所以最终输出i是每次的词法作用域中i的值</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2023/03/08/%E8%B7%A8%E5%9F%9F%EF%BC%8C%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"/>
      <url>/2023/03/08/%E8%B7%A8%E5%9F%9F%EF%BC%8C%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="跨域，解决方法"><a href="#跨域，解决方法" class="headerlink" title="跨域，解决方法"></a>跨域，解决方法</h1><h2 id="一、为什么出现跨域问题"><a href="#一、为什么出现跨域问题" class="headerlink" title="一、为什么出现跨域问题"></a>一、为什么出现跨域问题</h2><p>浏览器同源策略限制，是最核心的安全功能</p><p>可以说web是建立在同源策略基础上的，同源策略会阻止一个域的JavaScript脚本和另外一个域的内容进行交互，</p><p>同源，就是两个页面具有相同的协议（protocol），主机（host）和端口号（port）</p><h2 id="二、非同源限制"><a href="#二、非同源限制" class="headerlink" title="二、非同源限制"></a>二、非同源限制</h2><p>1.无法读取非同源页面的Cookie，LocalStorage和IndexedDB</p><p>2.无法接触非同源的DOM</p><p>3.无法向非同源地址发送AJAX请求</p><p>浏览器为了隔离潜在的恶意文件，使用同源策略，限制从一个源加载的文档或脚本和另一个源的资源进行交互（不同源之间的文档，资源的交互）;<br>通俗的理解：浏览器规定，A 网站的 JavaScript，不允许和非同源的网站 C 之间，进行资源的交互，例如：</p><p> 所谓同源（即指在同一个域）就是两个页面的<strong>协议（protocol），主机（host）和端口号（port）</strong>”三者相同;注意：跨域限制访问，其实是浏览器的限制。 </p><p><img src="https://img-blog.csdnimg.cn/fc92f8448fe54e96961f1f6e444db8c1.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAY29kaW5n6IuP,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h2 id="三、什么是跨域"><a href="#三、什么是跨域" class="headerlink" title="三、什么是跨域"></a>三、什么是跨域</h2><p>当一个请求url的协议，域名，端口三者之间任意一个与当前页面url不同的即为跨域</p><table><thead><tr><th>当前页面url</th><th>被请求页面url</th><th>是否跨域</th><th>原因</th></tr></thead><tbody><tr><td><a href="http://www.test.com/">http://www.test.com/</a></td><td><a href="http://www.test.com/index.html">http://www.test.com/index.html</a></td><td>否</td><td>同源（协议、域名、端口号相同）</td></tr><tr><td><a href="http://www.test.com/">http://www.test.com/</a></td><td><a href="https://www.test.com/index.html">https://www.test.com/index.html</a></td><td>跨域</td><td>协议不同（http&#x2F;https）</td></tr><tr><td><a href="http://www.test.com/">http://www.test.com/</a></td><td><a href="http://www.baidu.com/">http://www.baidu.com/</a></td><td>跨域</td><td>主域名不同（test&#x2F;baidu）</td></tr><tr><td><a href="http://www.test.com/">http://www.test.com/</a></td><td><a href="http://blog.test.com/">http://blog.test.com/</a></td><td>跨域</td><td>子域名不同（www&#x2F;blog）</td></tr><tr><td><a href="http://www.test.com:8080/">http://www.test.com:8080/</a></td><td><a href="http://www.test.com:7001/">http://www.test.com:7001/</a></td><td>跨域</td><td>端口号不同（8080&#x2F;7001）</td></tr></tbody></table><p> 浏览器对跨域请求的拦截: </p><p><img src="https://img-blog.csdnimg.cn/53b546f4a94742aea253ec39ebad8f52.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAY29kaW5n6IuP,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h2 id="四、跨域解决方法"><a href="#四、跨域解决方法" class="headerlink" title="四、跨域解决方法"></a>四、跨域解决方法</h2><h4 id="1-设置document-domain解决无法读取Cookie"><a href="#1-设置document-domain解决无法读取Cookie" class="headerlink" title="1.设置document.domain解决无法读取Cookie"></a>1.设置document.domain解决无法读取Cookie</h4><p>浏览器通过document.domain属性来检查两个页面是否同源，因此只要通过设置相同的document.domain,就可以共享Cookie（仅限用于主域相同，子域不同的跨域）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//两个页面都设置</span><br><span class="line">document.domain =&#x27;test.com&#x27;;</span><br></pre></td></tr></table></figure><h4 id="2-跨文档通信API：window-postMessage"><a href="#2-跨文档通信API：window-postMessage" class="headerlink" title="2.跨文档通信API：window.postMessage()"></a>2.跨文档通信API：window.postMessage()</h4><p>调用postMessage（）方法来实现父窗口<a href="http://test.com向子窗口http//test2.com%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF">http://test.com向子窗口http://test2.com发送消息</a></p><p>子窗口同样可以通过该方法发送消息给父窗口</p><p>可以解决以下问题：</p><p>1.页面和其打开的新窗口的数据传递</p><p>2.多窗口之间的消息传递</p><p>3.页面与嵌套的iframe(内框架页面)消息传递</p><p>上面三个场景的跨域数据传递</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//父窗口打开一个子窗口</span><br><span class="line">var openWidow = window.open(&#x27;http://test2.com&#x27;,&#x27;title&#x27;);</span><br><span class="line">//父窗口向子窗口发消息(第一个参数是发送的内容，第二个参数是接收消息窗口的url)</span><br><span class="line">openWindow.postMessage(&#x27;Nice to meet you!&#x27;,&#x27;http://test2.com&#x27;);</span><br></pre></td></tr></table></figure><p>调用message事件，监听对方发送的消息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//监听message消息</span><br><span class="line">window.addEventListener(&#x27;message&#x27;,function(e)&#123;</span><br><span class="line">console.log(e.source);//e.source 发送消息的窗口</span><br><span class="line">console.log(e.origin);//e.origin 消息发送的网址</span><br><span class="line">console.lof(e.data);  //e.data   发送的消息</span><br><span class="line">&#125;,false);</span><br></pre></td></tr></table></figure><h4 id="3-JSONP（JSON-with-Padding）"><a href="#3-JSONP（JSON-with-Padding）" class="headerlink" title="3.JSONP（JSON with Padding）"></a>3.JSONP（JSON with Padding）</h4><p>JSONP是服务器与客户端跨源通信的常用方法。</p><p>优点：简单使用，兼容性好，兼容低版本的IE</p><p>缺点：只支持get，不支持post请求</p><p>核心思想： 由于浏览器同源策略的限制，网页中无法通过 Ajax 请求非同源的接口数据。但是 <script >标签不受浏览器同源策略的影响，可以通过 src 属性，请求非同源的 js 脚本。 网页通过添加一个<script>元素，向服务完全请求JSON数据，服务器收到请求后将数据放在一个指定名字的回调函数的参数位置传回来</p><p>​1.原生实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 向服务器text.com发出请求，该请求的查询字符串有一个callback参数，用来指定回调函数的名字</span><br><span class="line">&lt;script src=&quot;http://test.com/data.php?callback=dosomething&quot;&gt;&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">// 处理服务器返回的回调函数的数据</span><br><span class="line">&lt;script type=&quot;text/jacascript&quot;&gt;</span><br><span class="line">function dosomething(res) &#123;</span><br><span class="line">//处理获取的数据</span><br><span class="line">console.log(res.data)</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>​2.jQury ajax:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">url:&#x27;http://www.test.com:8080/login&#x27;,</span><br><span class="line">type:&#x27;get&#x27;,</span><br><span class="line">dataType:&#x27;jsonp&#x27;//请求方法为jsonp</span><br><span class="line">jsonpCallback:&quot;handleCallback&quot;,//自定义回调函数名称</span><br><span class="line">data:&#123;&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><pre><code>   3.Vue.js</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">this.$http.jsonp(&#x27;http://www.domain2.com:8080/login&#x27;,&#123;</span><br><span class="line">params:&#123;&#125;,</span><br><span class="line">jsonp:&#x27;handleCallback&#x27;</span><br><span class="line">&#125;).then((res)=&gt;&#123;console.log(res)&#125;)</span><br></pre></td></tr></table></figure><h4 id="4-CORS"><a href="#4-CORS" class="headerlink" title="4.CORS"></a>4.CORS</h4><p>CORS是跨域资源分享（Cross-Origin Resoutce Sharing）的缩写。他是W3C标准，属于跨域AJAX请求的根本解决方法 支持 GET 和 POST 请求。缺点是不兼容某些低版本的浏览器:使用额外的HTTP头告诉浏览器被准许访问来自不同源服务器上的指定的资源。 </p><p>1.普通的跨域请求：只需要服务端设置Access-Control-Allow-Origin</p><p>2.带cookie的跨域请求：前后端都需要进行设置</p><p>​前端设置：</p><p>​1.原生ajax</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var xhr = new XMLHttpRequest();// IE8/9需用window.XDomainRequest兼容</span><br><span class="line">// 前端设置根据xhr.withCredentials字段判断是否带有cookie</span><br><span class="line">xhr.withCredentials = true;</span><br><span class="line"></span><br><span class="line">xhr.open(&#x27;post&#x27;,&#x27;http://www.domain2.com:8080/login&#x27;,true);</span><br><span class="line">// setrequestheader:设置发送请求的头;设置请求头类型;标头</span><br><span class="line">xhr.setRequestHeader(&#x27;Content-Type&#x27;,&#x27;application/x-  www-form-urlencoded&#x27;);</span><br><span class="line">xhr.send(&#x27;user=admin&#x27;);</span><br><span class="line"></span><br><span class="line">xhr.onreadystatechage = function()&#123;</span><br><span class="line">if(xhr.readyState == 4 &amp;&amp; xhr.status ==200) &#123;</span><br><span class="line">alert(xhr.respoonserText);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​2.axios</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//axios 默认值.有无证件 = 对</span><br><span class="line">axios.defaults.withCreedentials = true</span><br></pre></td></tr></table></figure><p>XMLHttpRequest 的 withCredentials 属性</p><p>默认值为false。在获取同域资源时设置 withCredentials 没有影响。<br>true：在跨域请求时，会携带用户凭证<br>false：在跨域请求时，不会携带用户凭证；返回的 response 里也会忽略 cookie</p><h4 id="5-webpack本地代理"><a href="#5-webpack本地代理" class="headerlink" title="5.webpack本地代理"></a>5.webpack本地代理</h4><p><img src="https://img-blog.csdnimg.cn/84424372b92f468f85454d2377839f25.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAY29kaW5n6IuP,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><p> 在webpack.config.js中利用 WebpackDevServer 配置本地代理，详情配置查看<a href="https://webpack.docschina.org/configuration/dev-server/#root">devServer</a> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">devServer: &#123;</span><br><span class="line">    port: 8080,</span><br><span class="line">    proxy: &#123;</span><br><span class="line">        &quot;/api&quot;: &#123;</span><br><span class="line">          target: &quot;http://192.168.122.55:8088&quot; // 后端接口</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="4-服务器使用Nginx的反向代理"><a href="#4-服务器使用Nginx的反向代理" class="headerlink" title="4. 服务器使用Nginx的反向代理"></a>4. 服务器使用Nginx的反向代理</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  user.subignquan.com;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        root   /usr/share/nginx/html;</span><br><span class="line">        index  index.html index.htm;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2023/03/08/%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%A4%9A%E7%A7%8D%E5%88%9B%E5%BB%BA%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/"/>
      <url>/2023/03/08/%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%A4%9A%E7%A7%8D%E5%88%9B%E5%BB%BA%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="早期创建方式"><a href="#早期创建方式" class="headerlink" title="早期创建方式"></a>早期创建方式</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`var` `obj = ``new` `Object()``obj.name =``&#x27;xxx&#x27;``obj.age = 18``或使用对象字面量``var` `o1 = &#123;`` ``name: ``&#x27;xxx&#x27;``,`` ``say: () =&gt; &#123;&#125;``&#125;``var` `o2 = &#123;`` ``name: ``&#x27;xxx&#x27;``,`` ``say: () =&gt; &#123;&#125;``&#125;`</span><br></pre></td></tr></table></figure><p>缺点：使用同一个接口创建很多对象，会产生大量重复代码</p><h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`function` `factory(name,age) &#123;`` ``var` `obj = ``new` `Object()`` ``obj.name = name`` ``obj.age = age`` ``return` `obj``&#125;``var` `o1 = factory(1, 11)``var` `o2 = factory(2, 22)`</span><br></pre></td></tr></table></figure><p>优点：解决了创建多个相似对象代码重复问题<br>缺点：无法识别对象是什么类型</p><h2 id="构造函数模式"><a href="#构造函数模式" class="headerlink" title="构造函数模式"></a>构造函数模式</h2><p>ECMAScript中可以使用构造函数创建特定类型的对象，如Object，Array这种原生构造函数。此外，也可以创建自定义构造函数，从而定义自定义对象的属性和方法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`function` `Person(name, age) &#123;`` ``this``.name = name`` ``this``.age = age`` ``this``.sayName = ``function``() &#123;``  ``console.log(``this``.name)`` ``&#125;``&#125;``var` `o1 = ``new` `Person(1,11)``var` `o2 = ``new` `Person(2,22)``o1.sayName() ``// 1``o2.sayName() ``// 2`</span><br></pre></td></tr></table></figure><p>优点：构造函数模式创建的实例可以区分类型标识(instanceof 判断)<br>缺点：每个方法都需要在实例上重新创建，如 两个实例的sayName方法任务相同，但是实际创建了两个Function实例</p><h2 id="构造函数模式优化"><a href="#构造函数模式优化" class="headerlink" title="构造函数模式优化"></a>构造函数模式优化</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`function` `Person(name, age) &#123;`` ``this``.name = name`` ``this``.age = age``&#125;``function` `sayName () &#123;`` ``console.log(``this``.name)``&#125;``var` `o1 = ``new` `Person(1,11)``var` `o2 = ``new` `Person(2,22)``o1.sayName() ``// 1``o2.sayName() ``// 2`</span><br></pre></td></tr></table></figure><p>优点：多个实例共享在全局作用域中定义的函数，解决了两个函数做同一件事的问题<br>缺点：全局作用域定义的函数实际上只能被某个对象调用，全局作用域名不副实，而且如果对象需要定义很多方法，需要创建很多个全局函数，这让自定义的对象类型没有封装特性。</p><h2 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h2><p>我们创建的每个函数都有一个protoype属性，这个属性是一个指针，指向一个对象。这个对象的用途是包含了可以由特定类型的所有实例共享的属性和方法。即prototype就是由构造函数创建的那个对象实例的原型对象</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`function` `Person()&#123;&#125;``Person.prototype.name = ``&#x27;123&#x27;``Person.prototype.age = 18``Person.prototype.sayName = ``function``() &#123;`` ``console.log(``this``.name)``&#125;``var` `o1 = ``new` `Person(1,11)``var` `o2 = ``new` `Person(2,22)``o1.sayName() ``// 123``o2.sayName() ``// 123`</span><br></pre></td></tr></table></figure><p>优点：解决了实例共享属性或事件的问题<br>缺点：因为实例共享属性的原因，对于值为引用类型的属性来说，一个实例的修改会导致其他实例访问值更改。如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`function` `Person()&#123;&#125;``Person.prototype.name = ``&#x27;123&#x27;``Person.prototype.age = 18``Person.prototype.friends = [``&#x27;a&#x27;``, ``&#x27;b&#x27;``]``Person.prototype.sayName = ``function``() &#123;`` ``console.log(``this``.name)``&#125;``var` `o1 = ``new` `Person(1,11)``var` `o2 = ``new` `Person(2,22)``o1.friends.push(``&#x27;c&#x27;``)``console.log(o2.friends) ``// [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]`</span><br></pre></td></tr></table></figure><h2 id="构造函数和原型模式组合"><a href="#构造函数和原型模式组合" class="headerlink" title="构造函数和原型模式组合"></a>构造函数和原型模式组合</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`function` `Person(name, age) &#123;`` ``this``.name = name`` ``this``.age = age`` ``this``.friends = [``&#x27;a&#x27;``]``&#125;``Person.prototype = &#123;`` ``constructor: Person,`` ``sayName: ``function``() &#123;``  ``console.log(``this``.name)`` ``&#125;``&#125;``var` `o1 = ``new` `Person(1,11)``var` `o2 = ``new` `Person(2,22)``o1.sayName() ``// 1``o2.sayName() ``// 2`</span><br></pre></td></tr></table></figure><p>优点：每个实例有自己的属性，同时又共享着方法的引用，还支持传参数</p><h2 id="动态原型模式"><a href="#动态原型模式" class="headerlink" title="动态原型模式"></a>动态原型模式</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`function` `Person(name, age) &#123;`` ``this``.name = name`` ``this``.age = age`` ``this``.friends = [``&#x27;a&#x27;``]`` ``if``(``typeof` `this``.sayName != ``&#x27;function&#x27;``) &#123;``  ``Person.prototype.sayName = ``function``() &#123;``   ``console.log(``this``.name)``  ``&#125;`` ``&#125;``&#125;``var` `o1 = ``new` `Person(1,11)``var` `o2 = ``new` `Person(2,22)``o1.sayName() ``// 1``o2.sayName() ``// 2`</span><br></pre></td></tr></table></figure><p>优点：仅在方法不存在的时候创建一次，避免重复创建</p><h2 id="寄生构造函数模式"><a href="#寄生构造函数模式" class="headerlink" title="寄生构造函数模式"></a>寄生构造函数模式</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`function` `SpecialArray() &#123;`` ``var` `o = ``new` `Array()`` ``// 添加值`` ``o.push.apply(o, arguments)`` ``// 添加方法`` ``o.toPipedString = ``function``()&#123;``  ``return` `this``.join(``&#x27;|&#x27;``)`` ``&#125;`` ``return` `o``&#125;``var` `o1 = ``new` `SpecialArray(1,11)``o1.toPipedString() ``// 1|11`</span><br></pre></td></tr></table></figure><p>优点：在不更改原始构造函数的情况下为对象添加特殊方法<br>缺点：返回的对象与构造函数以及构造函数的原型没有任何关系，该方法与在构造函数外部创建的对象没有什么不同</p><h2 id="稳妥构造函数模式"><a href="#稳妥构造函数模式" class="headerlink" title="稳妥构造函数模式"></a>稳妥构造函数模式</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`function` `Person(name) &#123;`` ``var` `o = ``new` `Object()`` ``// 添加方法`` ``o.getName = ``function``()&#123;``  ``return` `name`` ``&#125;`` ``return` `o``&#125;``var` `o1 = ``new` `Person(1)``o1.getName() ``// 1`</span><br></pre></td></tr></table></figure><p>与寄生构造函数不同在于，不使用this，不使用new调用<br>优点：除了使用getName外没有任何方法能够访问name，在一些安全的环境使用<br>缺点：与工厂模式相似，无法识别对象所属类型</p><p>以上就是js 创建对象的多种方式与优缺点小结的详细内容，更多关于js 创建对象的资料请关注脚本之家其它相关文章！</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2023/03/08/%E9%97%AD%E5%8C%85/"/>
      <url>/2023/03/08/%E9%97%AD%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>前端的默认行为之一， </p><p>只有函数内部的子函数·才能读取局部变量，所以闭包可以理解为定义在一个函数内部的函数</p><p>子函数使用父函数变量的行为</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">a</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="keyword">var</span> leo =<span class="number">1</span> ;</span><br><span class="line"> <span class="keyword">function</span> <span class="title function_">b</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="title function_">alert</span>(leo);</span><br><span class="line"> &#125;;</span><br><span class="line">&#125;;</span><br><span class="line">      <span class="title function_">b</span>();</span><br></pre></td></tr></table></figure><img src="C:\Users\GH\AppData\Roaming\Typora\typora-user-images\1658490311065.png" alt="1658490311065" style="zoom:50%;" /><p>延长父函数变量的生命周期</p><p>js定义的全局变量不会被回收</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">a</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="keyword">var</span> leo =<span class="number">1</span> ;</span><br><span class="line"> <span class="keyword">function</span> <span class="title function_">b</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="title function_">alert</span>(leo);<span class="comment">// 被调用之后，leo的生命周期延长</span></span><br><span class="line"> &#125;;</span><br><span class="line">       <span class="title function_">b</span>();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>拓展了父函数的空间</p><h3 id="环境和作用域"><a href="#环境和作用域" class="headerlink" title="环境和作用域"></a>环境和作用域</h3><p>环境被存在的价值是被需要，当不需要的时侯被销毁</p><p>作用范围&#x3D;&#x3D;&#x3D;作用域</p><p>类比城市(全局环境) 城市中的公园学校(函数作用域)，当这个作用域没有被使用，就会被销毁，当城市无人使用(如浏览器关闭)，全局被销毁。</p><p>   <img src="C:\Users\GH\AppData\Roaming\Typora\typora-user-images\1658539192828.png" alt="1658539192828"></p><h3 id="函数的环境和作用域"><a href="#函数的环境和作用域" class="headerlink" title="函数的环境和作用域"></a>函数的环境和作用域</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function show() &#123;</span><br><span class="line">let url = &quot;h&quot;</span><br><span class="line">&#125;</span><br><span class="line">show();</span><br><span class="line">show();</span><br></pre></td></tr></table></figure><p>当show()函数执行时，会在全局中创建一个函数的内部空间（环境），全新的执行上下文</p><p>当show()函数执行完了之后，创建的函数的作用域(作用范围)会被销毁掉</p><p>当第二个show()执行的收获，并不是继续使用上一个的作用域，而是会重新创建一个，等使用完后销毁</p><p>类似于玩游戏，一局和一局zhi’jian</p><p><img src="C:\Users\GH\AppData\Roaming\Typora\typora-user-images\1658539386379.png" alt="1658539386379"></p><p>作用域可以简单理解为继承关闭，子可以使用父的，父不可以使用子的。</p><p>返回一个引用类型就是返回了一个内存地址</p><h3 id="延申函数环境生命周期"><a href="#延申函数环境生命周期" class="headerlink" title="延申函数环境生命周期"></a>延申函数环境生命周期</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function hd() &#123;</span><br><span class="line">let n = 1;</span><br><span class="line">function sum () &#123;</span><br><span class="line">console.log (n++);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">hd();</span><br></pre></td></tr></table></figure><p>此时函数hd()调用开辟出了新的内存空间内部包含这 n，hd()</p><img src="C:\Users\GH\AppData\Roaming\Typora\typora-user-images\1658559496112.png" alt="1658559496112" style="zoom: 50%;" /><p>当再次调用hd()时，就有创建一个</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function hd() &#123;</span><br><span class="line"> let n = 1 ;</span><br><span class="line"> function sum () &#123;</span><br><span class="line"> console.log(n++);</span><br><span class="line"> &#125;</span><br><span class="line"> sum()</span><br><span class="line">&#125;</span><br><span class="line">hd(); hd();//无论调用多少次hd()，都只能输出2</span><br></pre></td></tr></table></figure><img src="C:\Users\GH\AppData\Roaming\Typora\typora-user-images\1658559669520.png" alt="1658559669520" style="zoom:50%;" /><p>当想要保留数据不被销毁，使外面的函数使用这个环境，当被使用时，不会被删除。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function hd() &#123;</span><br><span class="line">let m = 2;</span><br><span class="line">let n = 1;</span><br><span class="line">return function sum () &#123;</span><br><span class="line">console.log(++n)</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line">let a =hd();</span><br></pre></td></tr></table></figure><p>上面的n被返回的sum()函数使用，所以同样会被保留。(被return出去变成了全局的变量)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function hd() &#123;</span><br><span class="line">let m = 2;</span><br><span class="line">let n = 1;</span><br><span class="line">return function sum () &#123;</span><br><span class="line">console.log(++n)</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line">let a =hd();</span><br><span class="line">a();//2</span><br><span class="line">a();//3</span><br><span class="line">a();//4</span><br><span class="line">let b =hd();//每次新的调用，都会产生新的内存地址</span><br><span class="line">b();//2</span><br><span class="line">b();//3</span><br><span class="line">let c=hd()</span><br><span class="line">c();//2</span><br></pre></td></tr></table></figure><p><img src="C:\Users\GH\AppData\Roaming\Typora\typora-user-images\1658565086799.png" alt="1658565086799"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function hd() &#123;</span><br><span class="line">let n = 1;</span><br><span class="line">return function sum() &#123;</span><br><span class="line">let m = 1;</span><br><span class="line">        return function show() &#123;</span><br><span class="line">        console.log(++m);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line">let a = hd()();</span><br><span class="line">//此处的hd()()是 a=hd() 是将这个函数赋值给了a ，而a=hd()() 等于是将这个hd()函数的执行赋值给a</span><br><span class="line">a();</span><br><span class="line">a();</span><br></pre></td></tr></table></figure><p>如果环境定义的数据在被使用，那么就不会被删除</p><p><img src="C:\Users\GH\AppData\Roaming\Typora\typora-user-images\1658565897114.png" alt="1658565897114"></p><p>一直向下进行嵌套，最下面的被使用，那么上面的有作用域链关联的都不会被删除.</p><p><img src="C:\Users\GH\AppData\Roaming\Typora\typora-user-images\1658565416662.png" alt="1658565416662"></p><h3 id="构造函数中作用域的使用状态"><a href="#构造函数中作用域的使用状态" class="headerlink" title="构造函数中作用域的使用状态"></a>构造函数中作用域的使用状态</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function hd() &#123;</span><br><span class="line">let n=1;</span><br><span class="line">this.sun = function() &#123;</span><br><span class="line">console.log(++n);</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line"> let a = new hd();</span><br><span class="line"> a.sun ();</span><br><span class="line"> a.sun ();</span><br><span class="line"> let b = new hd();</span><br><span class="line"> b.sun ();</span><br><span class="line"> b.sun ();</span><br><span class="line"> 此处，创建构造函数（构造函数简单来说，就是去定义好的一个函数中加工一下）</span><br><span class="line"> </span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for (var i = 1 ; i&lt;=3; i++)&#123;</span><br><span class="line">console.log(i);//1,2,3</span><br><span class="line">&#125;</span><br><span class="line">consile.log(i)//4</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">for (var i =1 ; i&lt;=3 ; i++)&#123;</span><br><span class="line">setTimeout (()=&gt;&#123;</span><br><span class="line">console.log(i)</span><br><span class="line">&#125;1000)</span><br><span class="line">&#125;//4,4,4</span><br><span class="line">异步的队列，当for循环全部结束之后才会去执行setTimeout中的log</span><br><span class="line">而此时的i是4， 因为i等于3后依然进行了一次i++，然后进行比较无法匹配，才停止的for循环</span><br></pre></td></tr></table></figure><p>使用闭包来进行过滤</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr =[<span class="number">1</span>,<span class="number">2</span>,<span class="number">14</span>,<span class="number">41</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">14</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">534</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">57</span>,<span class="number">36</span>];</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">between</span>(<span class="params">a,b</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="title function_">funtion</span>(<span class="params">v</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> v&gt;= a &amp;&amp; v&lt;=b;<span class="comment">//此处的使用到了父级作用域的参数，形成了闭包</span></span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr.<span class="title function_">filter</span>(<span class="title function_">between</span>(<span class="number">3</span>,<span class="number">9</span>)));</span><br></pre></td></tr></table></figure><p>闭包动画</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2023/03/08/cosnt%E8%AF%A6%E8%A7%A3/"/>
      <url>/2023/03/08/cosnt%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="cosnt"><a href="#cosnt" class="headerlink" title="cosnt"></a>cosnt</h1><h3 id="一、为什么不可以修改"><a href="#一、为什么不可以修改" class="headerlink" title="一、为什么不可以修改"></a>一、为什么不可以修改</h3><p>const声明一个只读的常量。一旦声明，常量的值就不能改变。<br>只声明不赋值，就会报错。 const命令声明的常量也是不提升，同样存在暂时性死区，只能在声明的位置后面使用</p><p>const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动。对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指向实际数据的指针，const只能保证这个指针是固定的（即总是指向另一个固定的地址），至于它指向的数据结构是不是可变的，就完全不能控制了。因此，将一个对象声明为常量必须非常小心。</p><p><strong>对象类型</strong><br>引用类型 Object Function<br>引用地址，保存的只是一个指向实际数据的指针</p><p>基本类型 Number Boolean String undefined null<br>地址固定，值就保存在变量指向的那个内存地址</p><p><strong>也就是说，const声明引用类型的对象的话，值是能被改动的</strong><br>const声明基本类型的值就不能改动</p><p>const定义引用数据类，不能修改指针指向新的对象 ，但可以修改它指向的数据。</p><p>附：栈和堆javascript 中<br>基本数据类型 &#x3D;&#x3D;&gt;按值存储 const声明的基本数据类型存在 内存 栈 中</p><p>引用数据类型 &#x3D;&#x3D;&gt; 值存在 堆中 访问时引用地址 存在 内存 堆 中<br>数据本身保存在堆中，读取其数据时，先访问栈中的地址，通过地址找到存在堆中的数据</p><p>obj.a &#x3D; 2 ; 通过指针改变所指向的实体数据 const只能保证存在栈中的指针不可变<br>无法保证指向的内存属性发生变化<br>const a &#x3D; 1; a &#x3D; 2; 指针发生变化报错，会新开辟一个内存地址并把2赋值 给 a , a的指针发生改变</p><p>栈 保存的基本数据类型 大小是固定的<br>堆 保存的引用数据类型 大小是不固定的</p><h3 id="如何使const声明的对象内属性不可变，只可读？"><a href="#如何使const声明的对象内属性不可变，只可读？" class="headerlink" title="如何使const声明的对象内属性不可变，只可读？"></a>如何使const声明的对象内属性不可变，只可读？</h3><p> Object.freeze()。它的作用是冻结一个对象，被冻结的对象有以下几个特性： </p><ul><li>不能添加新属性</li><li>不能删除已有属性</li><li>不能修改已有属性的值</li><li>不能修改原型</li><li>不能修改已有属性的可枚举性、可配置性、可写性</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">    name: &#x27;张三&#x27;,</span><br><span class="line">    age: 18,</span><br><span class="line">    address: &#x27;上海市&#x27;</span><br><span class="line">&#125;</span><br><span class="line">obj.__proto__.habit = &#x27;运动&#x27;</span><br><span class="line"> </span><br><span class="line">// 冻结对象</span><br><span class="line">Object.freeze(obj)</span><br><span class="line"> </span><br><span class="line">// 不能添加新属性</span><br><span class="line">obj.sex = &#x27;男&#x27;</span><br><span class="line">console.log(obj)    // &#123;name: &quot;张三&quot;, age: 18, address: &quot;上海市&quot;&#125;</span><br><span class="line"> </span><br><span class="line">// 不能删除原有属性</span><br><span class="line">delete obj.age</span><br><span class="line">console.log(obj)    // &#123;name: &quot;张三&quot;, age: 18, address: &quot;上海市&quot;&#125;</span><br><span class="line"> </span><br><span class="line">// 不能修改已有属性的值</span><br><span class="line">obj.name = &#x27;李四&#x27;</span><br><span class="line">console.log(obj)    // &#123;name: &quot;张三&quot;, age: 18, address: &quot;上海市&quot;&#125;</span><br><span class="line"> </span><br><span class="line">// 不能修改原型</span><br><span class="line">obj.__proto__ = &#x27;随便什么值&#x27;</span><br><span class="line">console.log(obj.__proto__)  // &#123;habit: &quot;运动&quot;, constructor: ƒ, __defineGetter__: ƒ, __defineSetter__: ƒ, hasOwnProperty: ƒ, …&#125;</span><br><span class="line"> </span><br><span class="line">// 不能修改已有属性的可枚举性、可配置性、可写性</span><br><span class="line">Object.defineProperty(obj,&#x27;address&#x27;,&#123; // TypeError: Cannot redefine property: address</span><br><span class="line">    enumerable: false,</span><br><span class="line">    configurable: false,</span><br><span class="line">    writable: true</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p> 这里要注意一点，Object.freeze()的返回值就是被冻结的对象，该对象完全等于传入的对象，所以我们一般不需要接收返回值。上面我们对对象进行了冻结，那么我们可以冻结数组吗？ </p><h3 id="冻结数组"><a href="#冻结数组" class="headerlink" title="冻结数组"></a>冻结数组</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1,2,3,4,5]</span><br><span class="line">Object.freeze(arr)</span><br><span class="line">arr[0]=&#x27;新值&#x27;</span><br><span class="line">console.log(arr)    // [1, 2, 3, 4, 5]</span><br></pre></td></tr></table></figure><p> ，数组本质也就是对象，只不过对象的key是下标，所以也可以冻结。如果我的对象里还有对象呢，那么冻结是否依然有效？ </p><h3 id="浅冻结"><a href="#浅冻结" class="headerlink" title="浅冻结"></a>浅冻结</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">    name: &#x27;张三&#x27;,</span><br><span class="line">    info: &#123;</span><br><span class="line">        a: 1,</span><br><span class="line">        b: 2</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Object.freeze(obj)</span><br><span class="line">obj.name = &#x27;李四&#x27;</span><br><span class="line">console.log(obj)    // &#123;info: &#123;a: 1, b: 2&#125;,name: &quot;张三&quot;&#125;</span><br><span class="line">obj.info.a = 66</span><br><span class="line">console.log(obj.info)   // &#123;a: 66, b: 2&#125;</span><br></pre></td></tr></table></figure><p> 可以看到对象中如果还有对象的时候，Object.freeze()失效了。Object.freeze()只支持浅冻结，下面我们封装一个深冻结函数，日后可直接使用 </p><h3 id="深冻结"><a href="#深冻结" class="headerlink" title="深冻结"></a>深冻结</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">    name: &#x27;张三&#x27;,</span><br><span class="line">    info: &#123;</span><br><span class="line">        a: 1,</span><br><span class="line">        b: 2</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">function deepFreeze(obj) &#123;</span><br><span class="line">    // 获取所有属性</span><br><span class="line">    var propNames = Object.getOwnPropertyNames(obj)</span><br><span class="line"> </span><br><span class="line">    // 遍历</span><br><span class="line">    propNames.forEach(item =&gt; &#123;</span><br><span class="line">        var prop = obj[item]</span><br><span class="line">        // 如果某个属性的属性值是对象，则递归调用</span><br><span class="line">        if (prop instanceof Object &amp;&amp; prop !== null) &#123;</span><br><span class="line">            deepFreeze(prop)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    // 冻结自身</span><br><span class="line">    return Object.freeze(obj)</span><br><span class="line">&#125;</span><br><span class="line">deepFreeze(obj)</span><br><span class="line">obj.name = &#x27;李四&#x27;</span><br><span class="line">console.log(obj)    // &#123;name: &quot;张三&quot;, info: &#123;…&#125;&#125;</span><br><span class="line">obj.info.a = 100</span><br><span class="line">console.log(obj.info)   // &#123;a: 1, b: 2&#125;</span><br></pre></td></tr></table></figure><p>应用场景<br>Object.freeze()可以提高性能，如果你有一个对象，里面的内容特别特别多，而且都是一些静态数据，你确保不会修改它们，那你其实可以用Object.freeze()冻结起来，这样可以让性能大幅度提升，提升的效果随着数据量的递增而递增。一般什么时候用呢？对于纯展示的大数据，都可以使用Object.freeze提升性能。</p><h3 id="Vue中使用Object-freeze"><a href="#Vue中使用Object-freeze" class="headerlink" title="Vue中使用Object.freeze"></a>Vue中使用Object.freeze</h3><p>在vue项目中,data初始化 里面一般会有很多变量,后续如果不想使用它,可以使用Object.freeze()。这样可以避免vue初始化时候,做一些无用的操作,从而提高性能</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">data()&#123;</span><br><span class="line">    return&#123;</span><br><span class="line">        list:Object.freeze(&#123;&#x27;我不需要改变&#x27;&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Object.freeze()原理<br>模拟Object.freeze()原理主要用到两个关键方法，Object.definedProperty()、Object.seal()。</p><p>Object.definedProperty()方法可以定义对象的属性的特性。如可不可以删除、可不可以修改等等</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Object.defineProperty(person, &#x27;name&#x27;, &#123;</span><br><span class="line">    configurable: false,// 表示能否通过delete删除属性，能否修改属性的特性...</span><br><span class="line">    enumerable: false,// 表示是否可以枚举。直接在对象上定义的属性，基本默认true</span><br><span class="line">    writable: false,// 表示能否修改属性的值。直接在对象上定义的属性，基本默认true</span><br><span class="line">    value: &#x27;xm&#x27;// 表示属性的值。访问属性时从这里读取，修改属性时，也保存在这里。</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>通过上述配置，就能实现不能修改已有属性的值、不能修改已有属性的可枚举性、可配置性、可写性等等功能了</p><p>Object.seal()方法可以让对象不能被扩展、删除属性等等。用法：Object.seal(person)</p><p>通过Object.seal()方法可以实现不能删除，不能新增对象属性等等功能。通过这两个方法就可以实现一个简单的freeze方法了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function myFreeze(obj) &#123;</span><br><span class="line">    if (obj instanceof Object) &#123;</span><br><span class="line">        Object.seal(obj);</span><br><span class="line">        let p;</span><br><span class="line">        for (p in obj) &#123;</span><br><span class="line">            if (obj.hasOwnProperty(p)) &#123;</span><br><span class="line">                Object.defineProperty(obj, p, &#123;</span><br><span class="line">                    writable: false</span><br><span class="line">                &#125;);</span><br><span class="line">                myFreeze(obj[p]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2023/03/08/hello-world/"/>
      <url>/2023/03/08/hello-world/</url>
      
        <content type="html"><![CDATA[<p> 11111Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
